## ğŸ“Œ 0-1 BFS ì•Œê³ ë¦¬ì¦˜

--- 
```
í•´ë‹¹ ì•Œê³ ë¦¬ì¦˜ì€ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì¸ ê·¸ë˜í”„ì—ì„œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì— 0-1 BFSë¼ê³  ë¶ˆë¦°ë‹¤. 
ì‹œê°„ ë³µì¡ë„ëŠ” O(V * E)ë¡œ O(ê°„ì„ ì˜ ê°œìˆ˜)ì™€ ê°™ë‹¤.
```
<br>

> ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì¸ ì„ì˜ì˜ ì •ì  uì—ì„œ BFSë¥¼ ì‹¤í–‰í•´ë³´ë©´ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì²˜ëŸ¼ íì—ëŠ” ì˜¤ì§ ì´ì „ ì •ì ì„ í†µí•´ ìµœë‹¨ ê±°ë¦¬ê°€ ì¤„ì–´ë“  ì •ì ë§Œ íì— ì‚½ì…í•œë‹¤. 
> ê·¸ëŸ¬ë©´ íëŠ” í•­ìƒ ì‹œì‘ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ì— ëŒ€í•´ ì •ë ¬ëœ ìƒíƒœì´ë‹¤.
> <br> <br>
> 
> í˜„ì¬ ì •ì  Uì— ìˆë‹¤ê³  ê°€ì •í•´ë³´ì 
> <br>
> ê°„ì„ (U, V)ë¥¼ ì§€ë‚  ë•Œ ë‘ ê°€ì§€ ê²½ìš° ì¤‘ í•œ ê°€ì§€ê°€ ì¼ì–´ë‚œë‹¤.
> 1. Vì™€ UëŠ” ê°™ì€ ë ˆë²¨ì´ë‹¤.
> 2. Vì™€ UëŠ” 1ë ˆë²¨ ì•„ë˜ì´ë‹¤.
> <br>
> 
> ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì´ê¸° ë•Œë¬¸ì— ìœ„ ë‘ê°€ì§€ ê²½ìš°ë§Œ ë‚˜ì˜¤ê²Œ ë˜ë©°, ë‹¤ì‹œ ë§í•´ë³´ë©´
> 1. ê°€ì¤‘ì¹˜ê°€ 0ì´ë¼ëŠ” ê²ƒì€ Vì™€ Uê°€ ê°™ì€ ë ˆë²¨ì´ë‹¤.
> 2. ê°€ì¤‘ì¹˜ê°€ 1ì´ë¼ëŠ” ê²ƒì€ VëŠ” Uì˜ 1ë ˆë²¨ ì•„ë˜ì´ë‹¤.
> <br>  
> 
> ì´ë¡œì„œ, í˜„ì¬ Uì˜ ì •ì ì— ìˆë‹¤ë©´, íëŠ” ë ˆë²¨ì´ L[U] ë˜ëŠ” L[U] + 1ì¸ ì •ì ë§Œ ë“¤ì–´ìˆìœ¼ë©°, <br>
> ê°„ì„ (U, V)ì— ëŒ€í•´ L[U] ë˜ëŠ” L[U] + 1ì´ ì¡´ì¬í•œë‹¤. <br>
> ê·¸ëŸ¬ë¯€ë¡œ, V ì •ì ì´ Uì— ì˜í•´ ìµœë‹¨ê±°ë¦¬ê°€ ë‹¨ì¶•ë˜ì—ˆê³ , Uì™€ ê°™ì€ ë ˆë²¨ì´ë¼ë©´ íì˜ ì•ë¶€ë¶„ì— Vë¥¼ ì‚½ì…í•œë‹¤. 
> <br>  
> ë°˜ëŒ€ì˜ ê²½ìš° í ë’·ë¶€ë¶„ì— ì‚½ì…í•œë‹¤. <br>
> ì´ í–‰ìœ„ëŠ” BFSê°€ ì œëŒ€ë¡œ ì‘ë™í•˜ê¸° ìœ„í•´ íê°€ ì •ë ¬ëœ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ê²ƒì„ ë„ì™€ì¤€ë‹¤.
> <br>  
> ì¼ë°˜ì ì¸ í êµ¬ì¡°ë¡œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ê³ , ì‚½ì…ê³¼ ì •ë ¬ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ê²ƒì„ O(1)ë§Œì— ìˆ˜í–‰í•˜ì§€ ëª»í•œë‹¤. <br>
> ìš°ì„ ìˆœìœ„ í(Priority Queue)ëŠ” ì •ë ¬ëœ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ”ë° O(logN)ì„ ì†Œëª¨í•œë‹¤.<br>
> <br>
> ê·¸ë˜ì„œ ë±(Deque)ì´ë¼ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•œë‹¤.
> 1. ë‹¤ìŒ ì •ì  ì¶”ì¶œí•˜ê¸°
> 2. ê°€ì¥ ì•ìª½ì— ì‚½ì…í•˜ê¸°
> 3. ê°€ì¥ ë’¤ìª½ì— ì‚½ì…í•˜ê¸°
> <br>
> 
> ë±ì´ë¼ëŠ” ìë£Œêµ¬ì¡°ê°€ ìœ„ì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

---
## ğŸ“Œ ì˜ˆì‹œ ì½”ë“œ
```java
public class ì•Œê³ ìŠ¤íŒŸ_ë°±ì¤€_1261ë²ˆ {
    private static void bfsRun(int[][] arr) {
        int N = arr[0].length;
        int M = arr.length;
        int[] dx = new int[]{0, 1, 0, -1};
        int[] dy = new int[]{-1, 0, 1, -1};
        bfs(N, M, arr, dx, dy);
    }

    private static void bfs(int N, int M, int[][] arr,
                            int[] dx, int[] dy) {
        LinkedList<int[]> deque = new LinkedList<>();
        deque.offer(new int[]{0, 0, 0});
        arr[0][0] = -1;

        int x, y, nx, ny, c;
        int[] poll;
        while (!deque.isEmpty()) {
            poll = deque.poll();
            ;
            x = poll[0];
            y = poll[1];
            c = poll[2];

            if (x == N - 1 && y == M - 1) {
                System.out.println(c);
                return;
            }

            for (int i = 0; i < 4; i++) {
                nx = x + dx[i];
                ny = y + dy[i];
                if (checked(nx, ny, N, M)) continue;
                if (arr[ny][nx] == 0) deque.addFirst(new int[]{nx, ny, c});
                else deque.offer(new int[]{nx, ny, c + 1});
                arr[ny][nx] = -1;
            }
        }

        private static boolean checked ( int nx, int ny, int N, int M){
            return (nx < 0 || ny < 0 || nx >= N || ny >= M);
        }

        public static void main (String[]args){
            int[][] arr = new int[][]{
                    {0, 0, 1, 1, 1, 1},
                    {0, 1, 0, 0, 0, 0},
                    {0, 0, 1, 1, 1, 1},
                    {1, 1, 0, 0, 0, 1},
                    {0, 1, 1, 0, 1, 0},
                    {1, 0, 0, 0, 1, 0}
            };
            bfsRun(arr);
        }
    }
}
```
